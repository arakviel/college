# Паттерни взаємодії

## Вступ

У главах 5–8 розглянуто тактичні патерни проєктування, які визначають різні способи реалізації компонентів системи. Вони демонструють, як моделювати бізнес-логіку та архітектурно організовувати внутрішню частину обмеженого контексту.

У цій главі ми виходимо за межі одного компонента та розглядаємо патерни організації інформаційних потоків між елементами системи.

Патерни, описані в цій главі, спрощують міжконтекстну взаємодію з даними, усувають обмеження, накладені принципами проєктування агрегатів, а також виконують диспетчеризацію бізнес-процесів, що охоплюють кілька системних компонентів.

## Перетворення Моделей

**Обмежений контекст** визначає межі моделі та єдиної мови (_ubiquitous language_). У главі 3 було розглянуто різні патерни проєктування взаємодії між обмеженими контекстами.
Якщо команди, які реалізують два обмежені контексти, вільно спілкуються та готові до співпраці, вони можуть інтегруватися у партнерство. У такому випадку протоколи координації можуть встановлюватися разово, а питання інтеграції вирішуватися шляхом комунікації між командами.
Ще одним методом співпраці є створення **спільного ядра** (_shared kernel_), коли команди виділяють та розробляють спільну частину моделі, наприклад, шляхом винесення контрактів до окремого репозиторію.

## Взаємодія у відносинах «Клієнт-Постачальник»

У таких відносинах баланс сил зміщується або до **постачальника** (_supplier_), або до **споживача** (_consumer_).Якщо споживач не може адаптувати свою модель до моделі постачальника, необхідне складніше технічне рішення — **перетворення моделей** .
Перетворення може виконувати одна або обидві сторони:

- **Споживач** може адаптувати модель постачальника під свої потреби за допомогою **захисного шару** (_anticorruption layer, ACL_).

- **Постачальник** може діяти як **сервіс з відкритим протоколом** (_open-host service, OHS_), публікуючи інтеграційно-специфічну мову (_integration-specific published language_) для зменшення впливу змін на споживачів.

Оскільки логіка перетворення однакова для обох патернів (ACL та OHS), у цій главі розглядаються варіанти реалізації без акценту на їх відмінності, окрім виняткових випадків.

## Типи Перетворення Моделей

Перетворення моделі може бути:

- **Без збереження стану** — відбувається «на льоту» під час обробки вхідних (OHS) або вихідних (ACL) запитів.

- **З відстеженням стану** — потребує складнішої логіки та бази даних для зберігання змін.

### Перетворення без збереження стану

Для реалізації цього типу перетворення в контексті, якому належить трансформація (OHS для постачальника, ACL для споживача), застосовується патерн **проксі** (_proxy_).
Проксі перехоплює вхідні та вихідні запити, виконуючи зіставлення вихідної моделі з цільовою моделлю обмеженого контексту.

![](/images/46.png)

Реалізація проксі залежить від того, в якому режимі здійснюється взаємодія між обмеженими контекстами, у синхронному чи в асинхронному.

### Синхронний режим

Як показано на рис, типовим способом перетворення моделей, використовуваним за синхронного режиму взаємодії, є вбудовування логіки перетворення в кодову базу обмеженого контексту. У сервісі з відкритим протоколом (open-host service) перетворення в публічну мову відбувається під час обробки вхідних запитів, а на рівні запобіжного шару (anticorruption layer) - під час виклику вищого обмеженого контексту.

![](/images/47.png)

Іноді більш економічним і зручним варіантом може стати перенесення логіки перетворення на зовнішній компонент, наприклад на паттерн АРI-шлюзу (API Gateway). Цей компонент (АРI-шлюз, API Gateway) може бути програмним рішенням із відкритим вихідним кодом, як, наприклад, Kong або КrakenD або ж керованою службою хмарного провайдера, такою як А WS API Gateway, Google Apigee або Azure API Management. Для обмежених контекстів, що реалізують патерн сервісу з відкритим протоколом (open-host service), АРI-шлюз (API Gateway), за перетворення внутрішньої моделі на опубліковану мову відповідає мова (рyyyshed language), оптимізована для інтеграції. Крім того, як показано на рис. 9.3, наявність явного АРI-шлюзу (API Gateway) може полегшити процес управління та супроводу декількох версій API обмеженого контексту.

![](/images/48.png)

Запобіжний шар (anticorruption layer), реалізований за допомогою АРIшлюзу, може використовуватися кількома нижчими обмеженими контекстами. У таких випадках, як показано на рис, запобіжний шар (anticorruption layer) діє як обмежений контекст, спеціально призначений для інтеграції.
Такі обмежені контексти, що відповідають переважно за перетворення моделей для зручнішого використання іншими компонентами, часто називають
контекстами обміну.

![](/images/49.png)

### Асинхронний режим

Для перетворення моделей, використовуваних у режимі асинхронного обміну даними, можна реалізувати проксі: проміжний компонент, що підписується
на повідомлення, що надходять із вихідного обмеженого контексту. Проксі-сервер
виконає всі необхідні перетворення моделі та перешле отримані повідомлення цільовому передплатнику (рис).

![](/images/50.png)

Окрім перетворення моделі повідомлень, проксіруючий компонент також може зменшити шум у цільовому обмеженому контексті, відфільтровуючи непотрібні повідомлення.
Перетворення моделі в асинхронному режимі необхідне під час реалізації служби з відкритим хостом. Вельми поширеною помилкою є розробка та
надання опублікованої мови (рyyshead language) для об'єктів моделі
і дозвіл публікації подій предметної області в їхньому вихідному вигляді, що
розкриває модель реалізації обмеженого контексту. Перетворення в асинхронному режимі можна використовувати для перехоплення подій предметної області та
перетворення їх в опубліковану мову (рyyshed language) - це забезпечить
надійнішу інкапсуляцію деталей реалізації обмеженого контексту.
Крім того, переведення повідомлень на опубліковану мову (рublishеd language) дає змогу розрізняти закриті події, призначені для внутрішніх потреб обмеженого контексту, і відкриті події, призначені для інтеграції з іншими обмеженими контекстами.

![](/images/51.png)

### Перетворення моделей з відстеженням стану

Для більш істотних перетворень моделей, наприклад, коли механізм перетворення має агрегувати вихідні дані або об'єднати дані з
кількох джерел у єдину модель, - може знадобитися перетворення
з відстеженням стану. Давайте детально обговоримо кожен із цих варіантів
використання.

### Агрегування вхідних даних

Припустімо, що для оптимізації продуктивності обмежений контекст зацікавлений в агрегуванні вхідних запитів і їхній пакетній обробці. У цьому
випадку агрегування може знадобитися для всіх запитів, одержуваних як
у синхронному, так і в асинхронному режимі.

![](/images/52.png)

Іншим поширеним варіантом агрегування вихідних даних є
об'єднання кількох деталізованих повідомлень в одне повідомлення, що містить уніфіковані дані.

![](/images/53.png)

Перетворення моделі з накопиченням вхідних даних не може бути реалізовано за допомогою АРI-шлюзу (API Gateway), тому тут потрібне складніше
обробка з відстеженням стану. Для відстеження вхідних даних і відповідного їх опрацювання логіці перетворення потрібне власне постійне сховище.

![](/images/54.png)

У деяких випадках для перетворення з відстеженням стану можна замість створення власного рішення скористатися готовими продуктами, наприклад, платформою потокової обробки (Kafka, А WS Kinesis тощо) або рішенням
для пакетної обробки (Apache NiFi, А WS Glue, Spark тощо).

### Об'єднання декількох джерел

В обмеженому контексті може знадобитися обробка даних, накопичених
відразу з декількох джерел, включно з тими, що надходять з інших обмежених контекстів. Типовим прикладом такої обробки є застосування
патерну backend-for-frontend1
в якому користувацький інтерфейс має об'єднувати дані, що надходять одразу від кількох сервісів.
Ще один приклад - обмежений контекст, який повинен обробляти дані з безлічі інших контекстів і реалізовувати складну бізнес-логіку для
обробки всіх даних. У цьому випадку може бути корисно розділити складності
інтеграції та бізнес-логіки, покриваючи обмежений контекст запобіжним
шаром (anticorruption layer), що накопичує дані з усіх інших обмежених контекстів.

![](/images/55.png)

# Інтеграція агрегатів

У главі 6 вже говорилося, що одним із способів взаємодії між агрегатами і всією іншою системою є публікація подій предметної області. Зовнішні компоненти можуть підписуватися на ці події предметної області і виконувати свою логіку. Але як відбувається публікація подій предметної області в шині повідомлень?

Перш ніж перейти до рішення, давайте розглянемо кілька поширених помилок, які допускаються в процесі публікації подій, і наслідки кожного такого підходу. Розглянемо наступний код:

```csharp
public class Campaign
{
    List<DomainEvent> events;
    IMessageBus _messageBus;

    public void Deactivate(string reason)
    {
        foreach (var l in _locations.Values)
        {
            l.Deactivate();
        }

        IsActive = false;

        var newEvent = new CampaignDeactivated(id, reason);
        _events.Add(newEvent);
        _messageBus.Publish(newEvent);
    }
}
```

У рядку 17 створюється екземпляр нової події. У наступних двох рядках подія додається до внутрішнього списку подій предметної області агрегата (рядок 18) і публікується в шині повідомлень (рядок 19). Ця реалізація публікації подій предметної області проста, але неприйнятна. Публікація події предметної області прямо з агрегата є поганою практикою з двох причин:

1. Подія буде надіслана до того, як новий стан агрегата буде зафіксовано в базі даних. Підписник може отримати сповіщення про деактивацію кампанії, але це суперечитиме стану цієї кампанії.
2. Якщо транзакцію бази даних не вдасться зафіксувати через стан гонки (race condition), подальшу логіку накопичення, що робить операцію недійсною, або просто через технічну проблему в базі даних, подія вже буде опублікована і передана підписникам, і скасувати її буде неможливо.

Спробуємо інший варіант:

```csharp
public class ManagementAPI
{
    private readonly IMessageBus _messageBus;
    private readonly ICampaignRepository _repository;

    public ExecutionResult DeactivateCampaign(CampaignId id, string reason)
    {
        try
        {
            var campaign = _repository.Load(id);
            campaign.Deactivate(reason);
            _repository.CommitChanges(campaign);

            var events = campaign.GetUnpublishedEvents();
            foreach (var e in events)
            {
                _messageBus.Publish(e);
            }

            campaign.ClearUnpublishedEvents();
        }
        catch(Exception ex)
        {
            // Обробка помилок
        }
    }
}
```

У наведеному вище коді відповідальність за публікацію нових подій предметної області перенесена на прикладний рівень. У рядках 11-13 завантажується відповідний екземпляр агрегата `Campaign`, виконується його команда `Deactivate`, і тільки після того, як оновлений стан успішно зафіксовано в базі даних, у рядках з 15 по 20 нові події предметної області публікуються в шині повідомлень.

Але чи можна довіряти цьому коду? Ні, не можна. Процес, що виконує логіку, з певних причин може не опублікувати події предметної області. Можливо, шина повідомлень не працює. Або сервер, на якому виконується код, виходить з ладу відразу після фіксації транзакції бази даних, але перед публікацією подій. У цьому випадку система все одно буде перебувати в неконсистентному стані, тобто транзакція бази даних зафіксована, але події предметної області так і не були опубліковані.

## Патерн вихідних повідомлень (Outbox)

Патерн вихідних повідомлень забезпечує надійну публікацію подій предметної області за таким алгоритмом:

- Стан оновленого агрегата і нові події предметної області фіксуються в одній і тій самій атомарній транзакції.
- Ретранслятор повідомлень витягує тільки що зафіксовані події предметної області з бази даних.
- Ретранслятор публікує події предметної області в шині повідомлень.
- Після успішної публікації ретранслятор або позначає події як опубліковані в базі даних, або повністю їх видаляє.

![](/images/56.png)

При використанні реляційної бази даних краще скористатися її здатністю атомарно фіксувати дві таблиці та застосувати для зберігання повідомлень спеціально виділену таблицю.

![](/images/57.png)

При використанні бази даних NoSQL, яка не підтримує транзакції з декількома документами, вихідні події предметної області повинні бути вбудовані в запис агрегата. Наприклад:

```json
{
  "campaign-id": "364b33c3-2171-446d-b652-8e5a7b2belaf",
  "state": {
    "name": "Autumn 2017",
    "publishing-state": "DEACTIVATED",
    "ad-locations": []
  },
  "outbox": {
    "campaign-id": "364b33c3-2171-446d-b652-8e5a7b2belaf",
    "type": "campaign-deactivated",
    "reason": "Goals met",
    "published": false
  }
}
```

У цьому прикладі можна помітити додаткову властивість JSON-документа – `outbox`, що містить список подій предметної області, які підлягають публікації.

### Отримання неопублікованих подій

Публікуючий ретранслятор (_publishing relay_) може витягувати нові події предметної області двома способами:

#### 1. **Pull: запит до постачальника (producer)**

Ретранслятор може постійно запитувати базу даних на наявність неопублікованих подій. Щоб мінімізувати навантаження на базу даних через постійні запити, необхідно створювати відповідні індекси.

#### 2. **Push: відстеження журналу транзакцій**

Для проактивного виклику публікуючого ретранслятора при додаванні нових подій можна використовувати функціонал бази даних. Деякі реляційні бази дозволяють отримувати сповіщення про оновлення чи вставку записів шляхом відстеження журналу транзакцій. Деякі NoSQL-бази представляють зафіксовані зміни у вигляді потоків подій (наприклад, _AWS DynamoDB Streams_).

### Гарантія доставки

Патерн вихідних повідомлень (_outbox pattern_) гарантує як мінімум одноразову (_at least once_) доставку повідомлень. Якщо ретранслятор вийде з ладу відразу після публікації повідомлення, але до того, як воно буде позначене як опубліковане в базі, то це ж повідомлення буде повторно опубліковане під час наступної ітерації.

## Сага

Один з основних принципів побудови агрегатів — обмеження кожної транзакції одним екземпляром агрегата. Це забезпечує чітке визначення меж агрегата та їх інкапсуляцію в узгоджений набір бізнес-функцій. Однак бувають ситуації, коли потрібно реалізувати бізнес-процес, що охоплює кілька агрегатів.

### Приклад використання саги

При активації рекламної кампанії її рекламні матеріали повинні автоматично відправлятися видавцю. Після отримання підтвердження від видавця статус кампанії змінюється на `Published`. Якщо видавець відхиляє кампанію, вона позначається як `Rejected`.

Ця послідовність дій охоплює дві бізнес-сутності: рекламну кампанію та видавництво. Об’єднання їх в межах одного агрегата було б зайвим, оскільки вони належать до різних обмежених контекстів. Замість цього процес реалізовується у вигляді **саги**.

### Що таке сага?

Сага — це довготривалий бізнес-процес. Йдеться не обов’язково про час (саги можуть тривати від кількох секунд до кількох років), а скоріше про транзакції та бізнес-процеси, що охоплюють кілька транзакцій.

Транзакції можуть виконуватись не лише агрегатами, а й будь-яким компонентом, що генерує події предметної області та реагує на команди. Сага відстежує події, генеровані відповідними компонентами, і видає подальші команди іншим компонентам. Якщо один з кроків виконується з помилкою, сага відповідає за запуск компенсуючих дій, щоб зберегти узгодженість системи.

У наступному зображенні розглянемо, як реалізувати процес публікації рекламної кампанії за допомогою саги.

![](/images/58.png)

# Реалізація процесу публікації у сазі

Щоб реалізувати процес публікації, сага повинна відстежувати подію
CampaignActivated з агрегату Campaign та події PuЫishingConfirmed і
PuЫishingRejected з обмеженого контексту AdPuЫishing. Сага має виконати
команду SubmitAdvertisement для AdPuЬlishing та команди TrackPuЫishingConfirmation
і TrackPuЫishingRejection для агрегату Campaign. У цьому прикладі команда
TrackPuЫishingRejection є компенсуючою дією, яка гарантує, що рекламна кампанія
не буде позначена як активна. Розглянемо код:

```csharp
public class CampaignPuЬlishingSaga
{
    private readonly ICampaignRepository _repository;
    private readonly IPuЬlishingServiceClient _puЬlishingService;

    public void Process(CampaignActivated @event)
    {
        var campaign = _repository.Load(@event.Campaignid);
        var advertisingMaterials = campaign.GenerateAdvertisingMaterials();
        _puЫishingService.SubmitAdvertisement(@event.Campaignid, advertisingMaterials);
    }

    public void Process(PuЬlishingConfirmed @event)
    {
        var campaign = _repository.Load(@event.Campaignid);
        campaign.TrackPuЬlishingConfirmation(@event.Confirmationid);
        _repository.CommitChanges(campaign);
    }

    public void Process(PuЬlishingRejected @event)
    {
        var campaign = _repository.Load(@event.Campaignid);
        campaign.TrackPuЬlishingRejection(@event.RejectionReason);
        _repository.CommitChanges(campaign);
    }
}
```

У наведеному вище прикладі для доставки відповідних подій і реакції на них із виконанням відповідних команд використовується інфраструктура обміну повідомленнями. Це приклад відносно простої саги, оскільки вона не працює зі станами. Але нерідко трапляються саги, що вимагають керування станом: наприклад, для відстеження виконаних операцій, щоб у разі збою можна було прийняти відповідні компенсуючі заходи. У такій ситуації сага
може бути реалізована як агрегат, заснований на подіях, що зберігає повну історію отриманих подій і надісланих команд. Але логіка виконання
команди має бути винесена за межі самої саги та виконуватися асинхронно,
подібно до публікації подій предметної області у патерні вихідних повідомлень:

```csharp
public class CampaignPuЬlishingSaga
{
    private readonly ICampaignRepository _repository;
    private readonly IList<IDomainEvent> _events;

    public void Process(CampaignActivated activated)
    {
        var campaign = _repository.Load(activated.Campaignid);
        var advertisingMaterials = campaign.GenerateAdvertisingMaterials();
        var commandissuedEvent = new CommandissuedEvent(
            target: Target.PuЬlishingService,
            command: new SubmitAdvertisementCommand(activated.Campaignid, advertisingMaterials)
        );
        _events.Append(activated);
        _events.Append(commandissuedEvent);
    }

    public void Process(PuЬlishingConfirmed confirmed)
    {
        var commandissuedEvent = new CommandissuedEvent(
            target: Target.CampaignAggregate,
            command: new TrackConfirmation(confirmed.Campaignid, confirmed.Confirmationid)
        );
        _events.Append(confirmed);
        _events.Append(commandissuedEvent);
    }

    public void Process(PuЬlishingRejected rejected)
    {
        var commandissuedEvent = new CommandissuedEvent(
            target: Target.CampaignAggregate,
            command: new TrackRejection(rejected.Campaignid, rejected.RejectionReason)
        );
        _events.Append(rejected);
        _events.Append(commandissuedEvent);
    }
}
```

У цьому прикладі ретранслятор вихідних повідомлень повинен буде виконувати
команди на відповідних приймачах (endpoints) для кожного екземпляра
CommandissuedEvent. Як і у випадку з публікацією подій предметної області,
відокремлення переходу стану саги від виконання команд гарантує стабільне
виконання команд навіть при завершенні процесу помилкою на будь-якому етапі.

## Узгодженість

Попри те, що сага керує транзакцією, яка включає зміну
кількох компонентів, стан змінених компонентів у підсумку
підпорядковується принципу узгодженості (син. підсумкова узгодженість, eventual
consistency). І хоча сага зрештою виконає відповідні команди,
жодні дві транзакції не можна вважати атомарними. Це співвідноситься з ще одним
принципом побудови агрегатів:

> Строго узгодженими можна вважати лише дані в межах кордонів агрегату.
> А все, що поза цими кордонами, може вважатися узгодженим лише підсумково.

Скористайтеся цією обставиною як керівним принципом, щоб
переконатися у відсутності зловживання сагами з метою компенсації невірно
обраних меж агрегатів. Бізнес-операції, які повинні належати
одному агрегату, потребують строго узгоджених даних.

Сагу часто плутають із патерном диспетчера процесів. Хоча їхні реалізації подібні,
вони суттєво різняться. У наступному розділі буде розглянуто призначення патерну диспетчера процесів і його відмінності від патерну саги.

## Диспетчер процесів

Сага керує простим лінійним потоком дій. Строго кажучи, сага співвідносить події
з відповідними командами. У прикладах, використаних для демонстрації реалізації
саги, фактично відбувалася реалізація простого співвіднесення подій із командами:

- Подія `CampaignActivated` для команди `PuЬlishingService.SubmitAdvertisement`.
- Подія `PuЫishingConfirmed` для команди `Campaign.TrackConfirmation`.
- Подія `PuЫishingRejected` для команди `Campaign.TrackRejection`.

Патерн диспетчера процесів, показаний на рис, призначений для реалізації процесу, заснованого на бізнес-логіці. Він визначається як центральний
процесор, що підтримує стан послідовності та визначає наступні етапи обробки.

Як правило, якщо сага для вибору правильного курсу дій містить інструкції `if-else`, то це, найімовірніше, диспетчер процесів.

Ще одна відмінність диспетчера процесів від саги полягає в тому, що екземпляр
саги створюється неявно під час відстеження певної події, як у `CampaignActivated` у попередніх прикладах. А ось диспетчер процесів не може
бути прив’язаний до однієї вихідної події. Навпаки, це послідовний
бізнес-процес, що складається з кількох кроків. Отже, диспетчер процесів повинен бути створений явно.

![](/images/59.png)

Бронування місць для відрядження починається з того, що за алгоритмом маршрутизації обирають найекономічніший маршрут польоту, і співробітнику надходить прохання про його затвердження. Якщо співробітник віддає перевагу іншому маршруту,
його має схвалити безпосередній керівник цього співробітника. Після
бронювання рейсу необхідно забронювати один із попередньо затверджених готелів на відповідні дати. Якщо немає доступних готелів, квитки на
літак мають бути анульовані.
У цьому прикладі немає центрального об'єкта, що ініціює процес бронювання
поїздки. Бронювання місць - це процес, і він має бути реалізований як менеджер процесів.

![](/images/60.png)

З точки зору реалізації диспетчери процесів часто створюються у вигляді агрегатів,
заснованих або на станах, або на подіях. Наприклад:

```csharp
public class BookingProcessManager
{
    private readonly IList<IDomainEvent> events;
    private Bookingid id;
    private Destination destination;
    private TripDefinition _parameters;
    private Employeeid traveler;
    private Route route;
    private IList<Route> _rejectedRoutes;
    private IRoutingService _routing;

    public void Initialize(Destination destination,
                           TripDefinition parameters,
                           Employeeid traveler)
    {
        this.destination = destination;
        _parameters = parameters;
        this.traveler = traveler;
        route = _routing.Calculate(destination, parameters);

        var routeGenerated = new RouteGeneratedEvent(
            Bookingid: _id,
            Route: route
        );

        var commandIssuedEvent = new CommandIssuedEvent(
            command: new RequestEmployeeApproval(traveler, route)
        );

        _events.Append(routeGenerated);
        _events.Append(commandIssuedEvent);
    }

    public void Process(RouteConfirmed confirmed)
    {
        var commandIssuedEvent = new CommandIssuedEvent(
            command: new BookFlights(route, _parameters)
        );

        _events.Append(confirmed);
        _events.Append(commandIssuedEvent);
    }

    public void Process(RouteRejected rejected)
    {
        var commandIssuedEvent = new CommandIssuedEvent(
            command: new RequestRerouting(traveler, route)
        );

        _events.Append(rejected);
        _events.Append(commandIssuedEvent);
    }

    public void Process(ReroutingConfirmed confirmed)
    {
        _rejectedRoutes.Append(route);
        route = _routing.CalculateAltRoute(destination, _parameters, _rejectedRoutes);

        var routeGenerated = new RouteGeneratedEvent(
            Bookingid: id,
            Route: route
        );

        var commandIssuedEvent = new CommandIssuedEvent(
            command: new RequestEmployeeApproval(traveler, route)
        );

        _events.Append(confirmed);
        _events.Append(routeGenerated);
        _events.Append(commandIssuedEvent);
    }

    public void Process(FlightBooked booked)
    {
        var commandIssuedEvent = new CommandIssuedEvent(
            command: new BookHotel(destination, _parameters)
        );

        _events.Append(booked);
        _events.Append(commandIssuedEvent);
    }
}
```

У цьому прикладі диспетчер процесів має свій явно вказаний ідентифікатор
і постійний стан, що описує поїздку, яка потребує бронювання. Як і
в попередньому прикладі саги, диспетчер процесів підписується на події,
які керують робочим процесом (RouteConfirmed, RouteRejected, ReroutingConfirmed
тощо) і створює екземпляри подій типу CommandIssuedEvent, які будуть оброблятися
ретранслятором вихідних повідомлень для виконання конкретних команд.

### Висновок

У цьому розділі розглядалися різні патерни інтеграції компонентів системи. Глава почалася з вивчення патернів для перетворення моделей, які можна використовувати для реалізації захисного шару (anticorruption layer) або сервісів з відкритим протоколом (open-host service). Було показано, що перетворення можуть виконуватися на льоту або ж слідувати більш складній логіці, що вимагає відстеження станів.

Патерн вихідних повідомлень (outbox pattern) є надійним способом публікації подій предметної області, що належать агрегатам. Він гарантує коректну публікацію подій предметної області навіть у разі збоїв різних процесів.

Сагу можна використовувати для реалізації простих бізнес-процесів, до яких залучено кілька компонентів. Більш складні бізнес-процеси можуть бути реалізовані за допомогою патерна диспетчера процесів. Обидва патерни ґрунтуються на асинхронних реакціях на події предметної області та відправленні команд.

### Завдання

1.Який із патернів інтеграції з обмеженим контекстом вимагає реалізації логіки перетворення моделі?

**А)** Конформіст (conformist).

**Б)** Захисний шар (anticorruption layer).

**В)** Сервіс з відкритим протоколом (open-host service).

**Г)** Б і В.

2.Яка мета патерна вихідних повідомлень (outbox pattern)?

**А)** Відокремити інфраструктуру обміну повідомленнями від рівня бізнес-логіки системи.

**Б)** Забезпечити надійну публікацію повідомлень.

**В)** Підтримати реалізацію патерна моделі предметної області, заснованого на подіях (event-sourced domain model).

**Г)** А і Б.

3.Які є інші можливі варіанти використання патерна вихідних повідомлень (outbox pattern), окрім публікації повідомлень на шині повідомлень?

4.Чим сага відрізняється від диспетчера процесів?

**А)** Диспетчер процесів вимагає явного створення екземпляра, а екземпляр саги створюється неявно під час публікації відповідної події предметної області.

**Б)** На відміну від диспетчера процесів, сага ніколи не потребує збереження стану свого виконання.

**В)** Сазі потрібні компоненти, якими вона керує для реалізації патерна «Події як джерело даних» (Event Sourcing), а диспетчеру процесів вони не потрібні.

**Г)** Диспетчер процесів більше підходить для складних бізнес-процесів.

**Д)** Правильними є твердження А і Г.
