# Еврістика проєктування

## По обставинах

"По обставинах" – правильна, але не зовсім практична відповідь майже на будь-яке питання в галузі розробки програмного забезпечення. У цій главі ми розглянемо, від чого це "все залежить".

У першій частині книги розглядалися інструменти предметно-орієнтованого проєктування, призначені для аналізу предметних областей і прийняття стратегічних проєктних рішень. У другій частині розглядалися тактичні патерни проєктування: різні способи реалізації бізнес-логіки, організації архітектури системи та комунікації між компонентами системи. Ця глава об'єднує першу і другу частини. Тут будуть розглянуті евристичні прийоми застосування інструментів аналізу для прийняття різних рішень щодо проєктування програмних засобів, тобто предметно-орієнтованого (бізнесового) проєктування.

Але спочатку, оскільки ця глава присвячена евристиці проєктування, давайте почнемо з визначення самого поняття евристики.

## Евристика

Евристика – це не суворе правило, коректність якого гарантовано й математично доведена у 100% випадків. Скоріше, це правило з розряду емпіричних: досконалість не гарантується, але достатність для досягнення безпосередніх цілей, безсумнівно, є. Іншими словами, використання евристики – це ефективний підхід до розв'язання задач, що ігнорує шум, притаманний багатьом сигналам. Евристика дозволяє зосередити увагу на "переважаючих силах", відображених у найбільш важливих сигналах.

Евристики, представлені в цій главі, зосереджені на основних властивостях різних предметних областей і на сутностях задач, що вирішуються за допомогою різних проєктних рішень.

## Обмежені контексти

Як випливає з матеріалу, засвоєного під час вивчення глави 3, під визначення коректного обмеженого контексту (bounded context) можуть підходити як широкі, так і вузькі межі, охоплювані застосуванням несуперечливого єдиного словника (ubiquitous language). І все ж який оптимальний розмір обмеженого контексту? Це питання особливо важливе з огляду на часте ототожнення обмежених контекстів з мікросервісами. Чи потрібно завжди прагнути до найменших можливих обмежених контекстів? Як каже мій друг Нік Тьюн (Nick Tune):

> Для визначення меж сервісу існує безліч корисних і показових евристик. А його розмір належить до розряду найменш корисних.

Замість того, щоб перетворювати модель на функцію бажаного розміру (оптимізуючи під невеликі обмежені контексти), набагато ефективніше зробити навпаки: розглядати розмір обмеженого контексту як функцію моделі, яку він охоплює.

Зміни у програмних засобах, що впливають відразу на кілька обмежених контекстів, обходяться дорого і вимагають ретельної узгодженості, особливо якщо зачеплені обмежені контексти реалізуються різними командами. Подібні зміни, не інкапсульовані в один обмежений контекст, сигналізують про неефективне визначення меж контекстів. На жаль, реструктуризація меж обмеженого контексту є досить дорогою справою, і в багатьох випадках неефективність меж обходять стороною, що в підсумку призводить до накопичення технічного боргу.

![](/images/61.png)

Зміни, що порушують межі обмежених контекстів, зазвичай відбуваються,
коли предметна область недостатньо вивчена або бізнес-вимоги схильні до частих змін.
Широкі межі обмеженого контексту, або ж межі, що охоплюють відразу
кілька піддоменів, роблять менш небезпечними як помилки у визначенні меж,
так і помилки в моделюванні піддоменів, що входять до них. Реструктуризація логічних меж обходиться значно дешевше, ніж перевизначення фізичних
кордонів. Отже, під час розроблення обмежених контекстів слід починати з кордонів із ширшим охопленням. За необхідності, у міру набуття
знань предметної області, широкі межі потрібно звузити.

Така евристика застосовується в основному до обмежених контекстів, що охоплюють основні піддомени (core subdomains), оскільки як універсальні
(generic), так і допоміжні (supporting) підобласті вирізняються більшою
сформульованістю та гіршою мінливістю. Під час створення обмеженого контексту, що містить основний піддомен (core subdomain), від непередбачуваних змін можна захиститися, включивши до нього інші піддомени, з якими основний піддомен взаємодіє найчастіше. Це, як показано на
рис, можуть бути інші основні, або навіть допоміжні, або універсальні підобласті.

![](/images/62.png)

# Паперові реалізації бізнес-логіки

У главах 5-7, де детально розглядалася бізнес-логіка, були розкриті чотири різних способи її моделювання: транзакційний сценарій (transaction script), активна запис (active record), модель предметної області (domain model) і патерни моделі предметної області, заснованої на подіях (event-sourced domain model).

І транзакційний сценарій, і активна запис більше підходять для піддоменів з простою бізнес-логікою: наприклад, для допоміжних (supporting) підобластей або для інтеграції стороннього рішення в універсальну (generic) підобласть. Різниця між цими двома патернами полягає в складності структур даних. Транзакційний сценарій можна використовувати для простих структур даних, а активна запис допомагає інкапсулювати маппінг складних структур даних у базу даних.

Модель предметної області та її варіант, модель предметної області, заснована на подіях (event-sourced domain model), більше підходять для піддоменів зі складною бізнес-логікою, тобто для основних (core) піддоменів. Для тих основних піддоменів, які мають справу з фінансовими транзакціями і виконують зобов'язання перед законом по наданню журналу аудиту або ж вимагають глибокого аналізу поведінки системи, більше підходять моделі предметної області, засновані на подіях.

З урахуванням вищесказаного ефективна евристика вибору відповідного патерну реалізації бізнес-логіки полягає в тому, щоб задатися наступними питаннями:

- Чи відслідковує піддомен гроші або інші фінансові операції, чи має він надавати належний журнал аудиту або вимагати глибокого аналізу його поведінки? Якщо так, слід скористатися моделлю предметної області, заснованою на подіях (event-sourced domain model). Якщо ні, то ...
- Чи відрізняється бізнес-логіка піддомену особливою складністю? Якщо так, потрібно турбуватися про реалізацію моделі предметної області. Якщо ні, то ...
- Чи включає піддомен складні структури даних? Якщо так, слід скористатися патерном «Активна запис». Якщо ні, то ...
- Реалізувати транзакційний сценарій.

Завдяки існуванню тісного зв'язку між складністю піддомену та його типом, евристику, як показано на рис. 10.3, можна візуалізувати, використовуючи предметно-орієнтоване дерево рішень.

![](/images/63.png)

Для визначення різниці між складною і простою бізнес-логікою можна скористатися іншою евристикою. Межа між цими двома типами бізнес-логіки не дуже чітка, але важлива. Як правило, складна бізнес-логіка включає в себе складові бізнес-правила, інваріанти та алгоритми. А простий підхід стосується в основному перевірки вхідних даних. Ще одна евристика для оцінювання
складності стосується хитромудрості самої єдиної мови. Що покладено в її
основу - опис СRUD-операцій або ж опис складніших бізнес-процесів і правил?

Ухвалення рішення про патерн реалізації бізнес-логіки, що узгоджується з її
складністю і структурами даних, - це спосіб перевірки ваших припущень
про тип піддомену. Припустімо, що піддомен вважається основним ( core ), але найбільш підходящим бачиться шаблон активного запису або транзакційний сценарій. Або ж припустимо, що підобласть вважають допоміжною (supporting),
але вимагає моделі предметної області або моделі предметної області, заснованої на подіях (event-sourced domain model), у таких випадках з'являється чудова
можливість переглянути свої припущення про піддомен і про предметну область загалом. Слід пам'ятати, що конкурентна перевага основного піддомену не обов'язково має замикатися на технічну складову.

# Архітектурні патерни

У главі 8 розглядалися три архітектурні патерни: багаторівнева архітектура, порти та адаптери, і CQRS.

Виявлення передбачуваного патерну реалізації бізнес-логіки спрощує вибір архітектурного патерну:

- Для моделі предметної області, заснованої на подіях, потрібен CQRS. В іншому випадку система буде сильно обмежена в можливостях запиту даних, отримуючи лише один конкретний екземпляр агрегату за його ідентифікатором.
- Модель предметної області вимагає використання архітектури портів і адаптерів. В іншому випадку багаторівнева архітектура ускладнить реалізацію агрегатів та об'єктів-значень, які нічого не знають про системи збереження даних.
- Патерн активної записи найкраще поєднується з багаторівневою архітектурою з додатковим прикладним рівнем (сервісом) для логіки, що управляє активними записами.
- Патерн транзакційного сценарію може бути реалізований з мінімальною багаторівневою архітектурою, що складається всього з трьох рівнів.

Єдине виключення з попередньої евристики — це шаблон CQRS. Він може бути корисним не тільки для моделі предметної області, заснованої на подіях (event-sourced domain model), а й для будь-якого іншого патерну, якщо піддомену потрібно представлення своїх даних в кількох моделях збереження.

Дерево рішень для вибору архітектурного шаблону на основі цих евристик показано на рис.

![](/images/64.png)

### Стратегія тестування

Уявленням про патерн реалізації бізнес-логіки та про архітектурний шаблон
можна скористатися як евристикою для вибору стратегії тестування
кодової бази. Погляньте на три стратегії тестування, показані на рис.

![](/images/65.png)

Різниця між стратегіями тестування на малюнку полягає в тому, що вони акцентують увагу на різних типах тестів: модульних, інтеграційних та наскрізних. Давайте проаналізуємо кожну стратегію та контекст, у якому слід використовувати кожну модель.

### Піраміда тестування

У класичній піраміді тестування особливу увагу приділяють модульним
тестам, меншу - інтеграційним і ще меншу - наскрізним. Піраміди тестування найкраще підходять обом варіантам шаблонів моделі предметної
області. А з агрегатів і об'єктів-значень виходять ідеальні компоненти
для ефективного тестування бізнес-логіки.

### Ромб тестування

Ромб тестування в основному концентрується на інтеграційних тестах. Коли
використовується шаблон активного запису, бізнес-логіка системи за визначенням
поширюється як на сервісний шар, так і на шар бізнес-логіки. Тобто,
щоб зосередитися на інтеграції двох шарів, більш ефективним вибором
є ромб тестування.

### Перевернута піраміда тестування

У перевернутій піраміді тестування найбільша увага приділяється наскрізним
тестам: перевірці робочого процесу застосунку від початку до кінця. Такий порядок
найбільше підходить для кодових баз, що реалізують патерн "Транзакційний сценарій": бізнес-логіка проста, а кількість рівнів мінімальна, що робить
більш ефективною перевірку наскрізного потоку операцій, що проводяться в системі.
Дерево рішень щодо стратегії тестування показано на рис.

![](/images/66.png)

### Дерево тактичних проєктних рішень

Патерни бізнес-логіки, архітектурні патгерни та евристики стратегії тестування можна, як показано на рис, об'єднати й узагальнити за допомогою дерева
тактичних проєктних рішень.
Як бачите, визначення типів піддоменів і дотримання дерева рішень дає
надійну відправну точку для прийняття важливих проектних рішень. І тим не менш варто повторити, що це евристика, а не жорсткі правила. З кожного правила є винятки, не кажучи вже про евристики, які за визначенням не мають бути правильними у 100% випадків.

![](/images/67.png)

Дерево рішень ґрунтується на моїй перевазі у використанні простих інструментів і в застосуванні розширених шаблонів - моделі предметної області,
моделі предметної області, заснованої на подіях, CQRS тощо. - тільки
у разі крайньої необхідності. І все ж таки мені зустрічалися команди, які мають
великий досвід реалізації моделі предметної області, заснованої на подіях,
через що вона використовувалася ними для всіх створюваних піддоменів. Для них це
було простіше за використання різних патернів. Чи можна порекомендувати цей
підхід усім? Звісно, ні. У компаніях, у яких я працював або надавав консультаційні послуги, евристичний підхід виявився більш ефективним порівняно з
порівняно з використанням одного й того самого рішення для кожного завдання.

Зрештою, все залежить від вашого конкретного контексту. Деревом рішень,
показаним на рис, і евристикою проектування, на якому вона заснована,
можна скористатися як керівними принципами, але аж ніяк не як заміною критичного мислення.
заміни критичного мислення. Якщо виявиться, що краще підходять альтернативні евристики, не соромтеся змінювати керівні принципи або взагалі
вибудовувати власне дерево рішень.

# Висновок

Тут розглянуто порядок застосування знань про предметну область та її піддомени для прийняття технічних рішень: вибору безпечних меж обмежених контекстів, моделювання бізнес-логіки додатку та визначення архітектурного шаблону, необхідного для організації взаємодії внутрішніх компонентів кожного обмеженого контексту. В кінці глави ми торкнулися теми, яка часто є предметом бурхливих дискусій — який вид тестів важливіший, при цьому для визначення пріоритетів різних тестів відповідно до предметної області використовувався той самий фреймворк прийняття рішень.

Важливіше за саме прийняття проектних рішень — перевірка їх обґрунтованості з часом. У наступній главі обговорення буде перенесене на наступну фазу життєвого циклу розробки програмного забезпечення: еволюцію проектних рішень.

## Вправи

1. Припустимо, що впроваджується система управління життєвим циклом заявки WolfDesk (див. передмову). Вона є основним піддоменом, що вимагає глибокого аналізу поведінки, щоб з часом алгоритм можна було оптимізувати. Якою буде ваша початкова стратегія реалізації бізнес-логіки та архітектури компонента? Яка стратегія тестування буде обрана?

2. Якими будуть ваші проектні рішення для модуля управління зміною співробітників служби підтримки WolfDesk?

3. Щоб спростити процес управління змінами співробітників, виникла ідея скористатися зовнішнім постачальником відомостей про державні свята в різних географічних регіонах. Процес полягає в періодичному зверненні до зовнішнього постачальника та отриманні дат і назв майбутніх державних свят. Яку бізнес-логіку та архітектурні патерни ви б використали для реалізації інтеграції? Як би ви все це протестували?

4. Виходячи з вашого власного досвіду, які ще аспекти процесу розробки програмних засобів можна включити в евристичне дерево рішень, представлене в цій главі?
