# Еволюція проектних рішень

У нашому швидко змінному світі компанії не можуть дозволити собі навіть найменшу пасивність. Щоб не відстати від конкурентів, їм доводиться постійно змінюватися, розвиватися і навіть з часом знову «винаходити себе». Цей факт неможливо ігнорувати при проектуванні систем, особливо якщо планувати розробку програмних засобів, тісно адаптованих до вимог їх предметної області. Коли зміни не контролюються належним чином, навіть найвишуканіший і продуманий дизайн в кінцевому підсумку стає кошмаром для тих, хто займається його супроводом і розвитком. У цій главі розглядаються питання впливу змін у навколишньому середовищі програмного проєкту на проектні рішення і завдання відповідної еволюції проєкту.

У полі зору потрапляють чотири найбільш поширених вектори змін:

1. **Предметна область**
2. **Організаційна структура**
3. **Знання предметної області**
4. **Ріст проєкту**

## Зміни в предметних областях

З глави 2 відомо про три типи піддоменів і їх відмінності один від одного:

- **Основний (core)** — діяльність компанії, що відрізняється від діяльності її конкурентів з метою отримання конкурентних переваг.
- **допоміжний (supporting)** — те, що компанія робить інакше, ніж її конкуренти, але не забезпечує конкурентних переваг.
- **Універсальний (generic)** — те, що всі компанії роблять однаково.

З попередніх глав стало зрозуміло, що тип використовуваного піддомену впливає на стратегічні та тактичні проектні рішення:

- Як спроектувати межі обмежених контекстів.
- Як організувати інтеграцію контекстів.
- Які патерни (patterns) проектування слід використовувати з урахуванням складності бізнес-логіки.

Для розробки програмного продукту, орієнтованого на потреби предметної області, важливо визначити піддомені і їх типи. Але це ще не все. Не менш важливо простежити еволюцію піддоменів. Зі зростанням і розвитком організації часто трапляється так, що деякі з її піддоменів трансформуються з одного типу в інший. Розглянемо кілька прикладів таких змін.

### З основного в універсальний

Уявімо, що інтернет-компанія роздрібної торгівлі **BuyIT** впроваджує власне рішення для доставки замовлень. Вона розробила інноваційний алгоритм для оптимізації маршрутів своєї кур'єрської доставки і таким чином може стягувати меншу плату за доставку, ніж її конкуренти. Але з часом інша компанія **DeliveryIT** вносить зміни в сам процес доставки. Вона заявляє, що вирішила задачу «комівояжера» і пропонує як послугу оптимізацію шляху доставки. Оптимізація, яку пропонує компанія **DeliveryIT**, не тільки більш досконала, але й обходиться дешевше затрат компанії **BuyIT** на виконання тієї ж задачі.

З позиції **BuyIT**, як тільки рішення **DeliveryIT** стало доступним у вигляді готового продукту, його основна підобласть перетворилася в універсальну. Як результат, оптимальне рішення по доставці стало доступним усім конкурентам **BuyIT**. Без великих інвестицій в дослідження і розробку **BuyIT** більше не зможе отримати конкурентну перевагу в підобласті оптимізації шляху. Те, що раніше вважалося конкурентною перевагою **BuyIT**, стало товаром, доступним для всіх її конкурентів.

### З універсального в основний

З моменту свого створення компанія **BuyIT** використовує готове рішення для управління своїми запасами. Але звіти бізнес-аналітики постійно показують неадекватні прогнози потреб клієнтів. Отже, **BuyIT** не може поповнити свої запаси найбільш популярних продуктів і забиває склади непопулярними товарами. Оцінивши ряд альтернативних рішень по управлінню запасами, керівництво **BuyIT** приймає стратегічне рішення інвестувати в розробку і створення власної системи. Це внутрішнє рішення враховуватиме особливості продуктів, що продаються **BuyIT**, і більш якісно прогнозуватиме потреби клієнтів.

Рішення **BuyIT** замінити готове рішення власною реалізацією перетворило управління запасами з універсального піддомену в основний: успішна реалізація задуманої функціональності дасть **BuyIT** додаткову конкурентну перевагу перед іншими компаніями — конкуренти «застрягнуть» на загальному рішенні і не зможуть скористатися передовими алгоритмами прогнозування попиту, розробленими компанією **BuyIT**.

Прикладом з реального життя компанії, що перетворює універсальний піддомен в основний, є **Amazon**. Як і всім постачальникам послуг, компанії **Amazon** необхідна інфраструктура для роботи своїх сервісів. Компанія змогла «заново винайти» спосіб управління своєю фізичною інфраструктурою, а пізніше навіть перетворила його в прибутковий бізнес: **Amazon Web Services**.

### З допоміжного в универсальний

Відділ маркетингу компанії **BuyIT** впроваджує систему управління своїми постачальниками і їх контрактами. У системі немає нічого особливого або складного — це просто певні CRUD-інтерфейси для введення даних. Іншими словами, це типовий допоміжний піддомен. Але через кілька років після початку впровадження компанія **BuyIT** з'явилося рішення для управління контрактами з відкритим вихідним кодом. Відповідний проєкт реалізовував ту ж функціональність, що і в існуючому рішенні, але з більш досконалими функціями, такими як OCR і повнотекстовий пошук. Ці функції довго знаходились у **BuyIT** в списку запланованих робіт, але їм ніколи не надавалось першочергової уваги через їх незначний вплив на бізнес. І ось компанія вирішує відмовитися від внутрішньої розробки на користь інтеграції рішення з відкритим вихідним кодом. В результаті піддомен управління документами з допоміжного перетворюється на універсальний.

### З допоміжного в основний

допоміжний піддомен також може перетворитися в основний, наприклад, якщо компанія знайде спосіб оптимізувати допоміжну логіку таким чином, щоб це або знизило витрати, або принесло додатковий прибуток. Типовим показником подібного перетворення є зростаюча складність бізнес-логіки допоміжного піддомену. Самі по собі допоміжні піддомени за визначенням прості і в основному нагадують CRUD-інтерфейси або ж ETL-процеси. Але якщо бізнес-логіка з часом ускладнюється, для цього повинна бути цілком певна причина. Якщо зміни не впливають на прибуток компанії, то навіщо все ускладнювати? Це буде безпідставне ускладнення бізнесу. З іншого боку, якщо зміни підвищують прибутковість компанії, то це вже ознака того, що допоміжний піддомен стає основним.

### З основного в допоміжний

Основний піддомен може з часом стати допоміжним. Це може статися при безпідставній складності піддомену. Тобто, якщо від складності немає ніякої вигоди, тоді організація може вирішити позбутися від зайвої складності, залишивши мінімум логіки, необхідної для підтримки реалізації інших піддоменів.

### З універсального в допоміжний

І, нарешті, з тієї ж причини, що і в разі основного піддомену, універсальний піддомен може перетворитися на допоміжний. Повертаючись до прикладу з системою управління документами **BuyIT**, припустимо, що компанія вирішила, що складність інтеграції рішення з відкритим вихідним кодом не виправдовується отриманими при цьому перевагами і повернулася до власної системи. Як результат, універсальний піддомен перетворюється на допоміжний.

![](/images/68.png)

# Стратегічні аспекти проєктування

Зміна типу піддомену безпосередньо впливає на його обмежений контекст і, відповідно, на відповідні стратегічні проєктні рішення. Як відомо з глави 4, для різних типів підобластей підходять різні патерни інтеграції обмеженого контексту. Основні піддомени повинні захищати свої моделі за допомогою захисного шару (anticorruption layer) і захищати споживачів від частих змін у моделях реалізації за допомогою сервісу з відкритим протоколом (open-host service).
Іншим патерном інтеграції, на який впливають зміни типів, є патерн різних шляхів (separate ways). Як з'ясувалося раніше, команди можуть використовувати цей патерн для допоміжних та універсальних піддоменів. Якщо піддомен перетворюється на основний, дублювання його функцій кількома командами стає неприпустимим. Тому у команд немає іншого вибору, крім як інтегрувати свої реалізації. У цьому випадку найбільший сенс мають відносини типу споживач-постачальник (customer-supplier), оскільки основний піддомен буде реалізований тільки однією командою.
З точки зору стратегії реалізації основні та допоміжні піддомени відрізняються за способом їх реалізації. Допоміжні піддомени можна передати на аутсорсинг або використовувати як тренажер для нових співробітників. Основні піддомени повинні бути реалізовані всередині компанії, як можна ближче до джерел знань про предметну область. Тому, коли допоміжний піддомен перетворюється на основний, його реалізацію слід перенести в компанію. Така ж логіка працює і в зворотному напрямку. Якщо основний піддомен перетворюється в допоміжний, його реалізацію можна передати на аутсорсинг, щоб дозволити внутрішнім групам досліджень і розробок зосередитися на основних піддомена.

# Тактичні аспекти проєктування

Основним показником зміни типу піддомену є неспроможність існуючого технічного дизайну підтримувати поточні потреби бізнесу.
Повернемося до прикладу допоміжного піддомену, який став основним. Допоміжні піддомени реалізуються за допомогою відносно простих патернів проєктування, використовуваних для моделювання бізнес-логіки: транзакційний сценарій (transaction script) або патерн активної записи (active record); Як відомо з глави 5, ці патерни погано підходять для бізнес-логіки, яка включає складні правила та інваріанти.
Якщо з часом до бізнес-логіки додаються складні правила та інваріанти, кодова база також ускладнюватиметься. Додавати новий функціонал буде занадто проблематично, оскільки дизайн не підтримуватиме новий рівень складності. Це "проблематичність" стане важливим сигналом. Скористайтеся ним як закликом до переоцінки предметної області та варіантів дизайну.
Необхідності змінювати стратегію реалізації не потрібно боятися. Це нормально. Ми не завжди можемо передбачити подальший розвиток бізнесу. Ми також не можемо застосовувати найскладніші патерни проєктування для всіх типів піддоменів: це було б марнотратно і неефективно. Потрібно вибрати найбільш підходящий дизайн і розвивати його за необхідності.
Якщо рішення про те, як моделювати бізнес-логіку, приймається свідомо, і відомі всі можливі варіанти дизайну, а також відмінності між ними, перехід від одного патерна проєктування до іншого не буде таким важким. Відповідні приклади розглянуті в наступних підрозділах.

# Перетворення транзакційного сценарію в активну запис

По суті, і транзакційний сценарій, і патерн "Активна запис" ґрунтуються на одному і тому ж принципі: бізнес-логіка реалізована у вигляді процедурного сценарію. Різниця між ними полягає в тому, як моделюються структури даних: патерн "Активна запис" вводить структури даних з метою інкапсуляції складності їх співставлення з механізмом зберігання.
У зв'язку з цим, коли робота з даними в транзакційному сценарії ускладнюється, його слід реорганізувати в шаблон активної запису. Шукайте складні структури даних і інкапсулюйте їх у об'єкти патерну "Активна запис". Замість прямого доступу до бази даних використовуйте патерн "Активна запис" для абстрагування її моделі та структури.

# Перетворення активної записи в модель предметної області

Якщо бізнес-логіка, що маніпулює активними записами, стає складною, і спостерігається все більше випадків невідповідностей і дублювання, реалізацію слід перетворити на патерн моделі предметної області (domain model).

Почніть з визначення об'єктів-значень (value-objects). Відповідайте на питання: які структури даних можна змоделювати як незмінні об'єкти? Знайдіть відповідну бізнес-логіку і зробіть її частиною об'єктів-значень.

Згодом проаналізуйте структури даних і визначте межі транзакцій. Щоб переконатися, що вся логіка зміни стану є явною, зробіть усі функції призначення значень активних записів закритими, щоб значення можна було змінювати тільки зсередини самих активних записів. Зрозуміло, що компіляція зазнає збоїв, але помилки компіляції допоможуть зрозуміти, де саме знаходиться логіка, яка змінює стан. Перетворіть цю логіку на межі активної записі. Наприклад:

```csharp
public class Player
{
    public Guid Id { get; set; }
    public int Points { get; set; }

    public class ApplyBonus
    {
        public void Execute(Guid playerId, byte percentage)
        {
            var player = _repository.Load(playerId);
            player.Points *= 1 + percentage / 100.0;
            _repository.Save(player);
        }
    }
}
```

У наступному коді видно перші кроки до перетворення. Код поки не скомпілюється, але помилки виявлять, де саме зовнішні компоненти контролюють стан об'єкта:

```csharp
public class Player
{
    public Guid Id { get; private set; }
    public int Points { get; private set; }

    public class ApplyBonus
    {
        public void Execute(Guid playerId, byte percentage)
        {
            var player = _repository.Load(playerId);
            player.Points *= 1 + percentage / 100.0;
            _repository.Save(player);
        }
    }
}
```

На наступному кроці можна перемістити логіку внутрішньо в межі активної записі:

```csharp
public class Player
{
    public Guid Id { get; private set; }
    public int Points { get; private set; }

    public void ApplyBonus(int percentage)
    {
        this.Points *= 1 + percentage / 100.0;
    }
}
```

Коли вся бізнес-логіка, що змінює стан, переміщена в межі відповідних об'єктів, перевірте, які ієрархії необхідні для забезпечення строгої перевірки бізнес-правил та інваріантів. Вони є хорошими кандидатами для агрегатів. Пам'ятаючи про принципи побудови агрегатів, розглянутих у главі 6, шукайте найменші межі транзакцій, тобто мінімальну кількість даних, необхідну для забезпечення строгої узгодженості. Розкладіть ієрархії вздовж цих меж. Переконайтесь, що посилання на зовнішні агрегати йдуть лише по їхніх ідентифікаторах.

Завершіть визначенням для кожного агрегату його кореня або точки входу для його публічного інтерфейсу. Зробіть методи всіх інших внутрішніх об'єктів в агрегаті закритими і викликаються лише з агрегату.

# Перетворення моделі предметної області в модель предметної області, засновану на подіях

Коли є модель предметної області з правильно спроектованими межами агрегатів, її можна перетворити на модель, засновану на подіях (event-sourced domain model). Замість прямого зміни даних агрегату змоделюйте події предметної області, необхідні для представлення життєвого циклу агрегату.

Найскладнішим аспектом перетворення моделі предметної області на модель
предметної області, заснованої на подіях, є історія наявних
агрегатів: міграція "безчасового" стану в модель, засновану на подіях. Оскільки докладних даних, що представляють усі минулі зміни стану, - немає, потрібно або згенерувати минулі події в міру можливості,
або змоделювати події міграції.

### Генерація минулих переходів стану

Цей підхід передбачає створення приблизного потоку подій для кожного агрегата, щоб цей потік можна було спроектувати в таке ж подання стану, як і в початковій реалізації. Розглянемо приклад, наведений у главі 7 та представлений в таблиці 11.1.

#### Таблиця 11.1. Подання даних агрегата на основі стану

| Номер | Ім'я   | Прізвище | Номер телефону | Статус    | Дата останнього контакту | Дата останнього замовлення |
| ----- | ------ | -------- | -------------- | --------- | ------------------------ | -------------------------- |
| 12    | Shauna | Mercia   | 555-4753       | converted | 2020-05-27T12:02:12.51Z  | 2020-05-27T12:02:12.51Z    |

З точки зору бізнес-логіки можна припустити, що екземпляр агрегата був ініціалізований, потім зв'язались з людиною, оформлено замовлення, а в кінці, оскільки статус був "перетворений" ("converted"), підтверджено оплату замовлення. Усі ці переходи стану можуть бути представлені наступним набором подій:

```json
{
  "lead-id": 12,
  "event-id": 0,
  "event-type": "lead-initialized",
  "first-name": "Shauna",
  "last-name": "Mercia",
  "phone-number": "555-4753"
},
{
  "lead-id": 12,
  "event-id": 1,
  "event-type": "contacted",
  "timestamp": "2020-05-27T12:02:12.51Z"
},
{
  "lead-id": 12,
  "event-id": 2,
  "event-type": "order-submitted",
  "payment-deadline": "2020-05-30T12:02:12.51Z",
  "timestamp": "2020-05-27T12:02:12.51Z"
},
{
  "lead-id": 12,
  "event-id": 3,
  "event-type": "payment-confirmed",
  "status": "converted",
  "timestamp": "2020-05-27T12:38:44.12Z"
}
```

Послідовне застосування цих подій дозволяє спроектувати точне подання стану, як і в початковій системі. "Відновлені" події можна легко протестувати, спроеціювавши стан і порівнявши його з початковими даними.

Важливо пам'ятати про недоліки такого підходу. Метою використання подій як джерела даних (event sourcing) є отримання надійної та послідовної історії подій предметної області для агрегатів. Проте, таким чином, неможливо відновити повну історію переходів станів. У попередньому прикладі ми не знаємо, скільки разів агент по продажах зв'язувався з людиною, і тому скільки подій "виходу на зв'язок" ми пропустили.

### Моделювання подій міграції

Альтернативний підхід полягає в тому, щоб змиритися з відсутністю знань про минулі події та явно змоделювати їх як подію. Замість відновлення подій, які могли б призвести до поточного стану, слід визначити подію міграції та використовувати її для ініціалізації потоків подій існуючих екземплярів агрегата:

```json
{
  "lead-id": 12,
  "event-id": 0,
  "event-type": "migrated-from-legacy",
  "first-name": "Shauna",
  "last-name": "Mercia",
  "phone-number": "555-4753",
  "status": "converted",
  "last-contacted-on": "2020-05-27T12:02:12.51Z",
  "order-placed-on": "2020-05-27T12:02:12.51Z",
  "converted-on": "2020-05-27T12:38:44.12Z",
  "followup-on": null
}
```

Перевагою цього підходу є те, що в ньому явно визнається відсутність минулих даних. Ні на якому етапі ніхто не може помилково припустити, що потік подій фіксує всі події предметної області, які сталися протягом життєвого циклу екземпляра агрегата. Недоліком є те, що в сховищі подій назавжди залишаться сліди застарілої системи. Наприклад, якщо використовується патерн CQRS (ймовірно, з моделлю предметної області, заснованою на подіях), проекції завжди повинні враховувати події міграції.

### Організаційні зміни

На структуру системи можуть вплинути й зміни в самій організації. У главі 4 були розглянуті різні моделі інтеграції обмежених контекстів: партнерство (partnership), загальне ядро (shared kernel), конформіст (conformist), сервис с открытым протоколом и разные пути. Изменения
в структуре организации могут повлиять на уровни общения и совместной работы
команд и, как следствие, на способы интеграции ограниченных контекстов.
Типичный пример такого изменения - выросшие центры разработки (рис).
Поскольку ограниченный контекст может быть реализован только одной командой,
добавление новых групп разработчиков может привести к тому, что существующие
ограниченные контексты с более широкими границами будут разбиты на более
мелкие, чтобы каждая группа могла работать со своим собственным ограниченным
контекстом.

![](/images/69.png)

**Більш того, наявні в організації центри розробки часто знаходяться в різних географічних точках.**
Коли робота над існуючими обмеженими контекстами переноситься в інше місце, це може негативно вплинути на співпрацю команд. В результаті патерни інтеграції обмежених контекстів повинні розвиватися належним чином відповідно до описів наведених нижче сценаріїв.

## Перехід від партнерства до відносин споживач-постачальник

Модель партнерства передбачає тісний зв'язок між командами та їхнє співробітництво. З часом ситуація може змінитися. Наприклад, коли робота над одним з обмежених контекстів переміщується в віддалений центр розробки. Таке зміщення ускладнить зв'язок між командами і може стати причиною переходу від моделі партнерства до відносин клієнт-постачальник.

## Перехід від відносин споживач-постачальник до моделі різних шляхів

На жаль, у команд часто виникають серйозні проблеми з комунікацією. Проблеми можуть бути спричинені географічною віддаленістю або організаційною політикою. З часом такі команди можуть зіткнутися з все більшими проблемами інтеграції. В якийсь момент може виявитися, що більш вигідно дублювати функціональність, виключивши необхідність постійно "доганяти" один одного.

## Знання предметної області

Згадаємо, що основний принцип предметно-орієнтованого проектування полягає в тому, що для розробки успішної програмної системи необхідні знання предметної області. Оволодіння знаннями предметної області є одним з найскладніших аспектів розробки програмного забезпечення, особливо коли йдеться про основні піддомени. Логіка основного піддомену не лише складна, але й схильна до частих змін. Більше того, моделювання є неперервним процесом. І по мірі набуття нових знань у предметній області моделі повинні удосконалюватися.

Часто складність предметної області не лежить на поверхні. Спочатку все здається простим і зрозумілим, але початкова простота часто виявляється оманливою і швидко перетворюється на складність. У процесі додавання нових функцій з'являються все більше і більше граничних випадків, інваріантів та правил. Усвідомлення нових обставин іноді призводить до руйнівного ефекту, вимагаючи перепроектування моделі з нуля, включаючи межі обмежених контекстів, агрегатів і інших деталей реалізації.

## Стратегічний підхід до проектування обмежених контекстів

З точки зору стратегічного проектування корисною евристикою є проектування меж обмежених контекстів відповідно до рівня знань предметної області. Витрати на поділ системи на обмежені контексти, які виявилися згодом неправильними, можуть бути досить високими. Тому, коли логіка предметної області незрозуміла і схильна до частих змін, доцільно проектувати обмежені контексти з більш широкими межами. Потім, коли набувається більше знань і зменшується змінність бізнес-логіки, ці широкі обмежені контексти можна поділити на контексти з меншим охопленням або на мікросервіси.

## Важливість збереження знань предметної області

При виявленні нових аспектів предметної області їх слід використовувати для розвитку дизайну і підвищення його стабільності. На жаль, зміни в знаннях предметної області не завжди мають позитивний аспект, буває так, що знання втрачаються. З часом застаріває документація, з компанії йдуть люди, які спочатку працювали над проектом, а наївне (ad hoc) додавання нових функцій призводить до того, що в якийсь момент кодова база набуває статусу унаследованої системи.

## Зростання проекту

Зростання проекту є ознакою здорової системи. Постійне додавання нових функцій свідчить про успішність системи, яка приносить явну користь своїм клієнтам і розширюється для повнішого задоволення потреб користувачів, зберігаючи рівень сервісу, порівнянний з конкурентними продуктами. Але у зростання є й темна сторона. З часом кодова база проекту може перетворитися на великий клубок бруду:
_«Великий клубок бруду» — безладний, розпадаючийся, що складається з кістилів та ізоляційної стрічки лапшекод (спагеті-код). Такі системи мають явні ознаки безладного зростання через необхідність постійного внесення хаїв і кістилів._

- Брайан Фут і Джозеф Йодер (Brian Foote and Joseph Yoder)

Неконтрольоване зростання, що призводить до формування великих клубків бруду, є результатом розширення функціональності програмної системи без перегляду її проектних рішень. Зростання розширює межі компонентів, збільшуючи їхні функціональні можливості. Вивчення впливу зростання на дизайн є надзвичайно важливим, оскільки багато інструментів предметно-орієнтованого проектування пов'язані з визначенням меж: структурні бізнес-блоки (піддомени), модель (обмежені контексти), незмінність (об'єкти-значення) або узгодженість (агрегати).

## Керівний принцип боротьби зі складністю, викликаною зростанням продукту

Принцип боротьби зі складністю, що виникає від росту продукту, полягає в ідентифікації та усуненні непотрібної складності, спричиненої застарілим дизайном. Необхідною складністю або складністю, притаманною предметній області, потрібно керувати за допомогою інструментів та методів предметно-орієнтованого проектування.

## Піддомени

Як відомо з глави 1, визначити межі піддомена буває нелегко, в результаті чого замість прагнення до визначення ідеальних меж потрібно намагатися знайти такі межі, від яких можна отримати максимальну вигоду. ТОбто піддомени мають давати змогу ідентифікувати компоненти з різною бізнес-цінністю, а для відпрацювання рішення слід скористатися відповідними інструментами.
У міру зростання предметної області межі піддомену можуть розмиватися ще
більше, що ускладнить виявлення тих випадків, коли піддомен охопить одразу кілька дрібніших піддоменів. Отже, важливо переглянути ідентифіковані підобласті та скористатися евристикою узгоджених сценаріїв
дій (наборів сценаріїв дій, що працюють з одним і тим самим набором
даних), щоб спробувати визначити, де можна буде розбити піддомен.

![](/images/70.png)

## Здатність виділяти дрібніші підобласті різних типів

Це пов'язано з важливою навичкою проникати вглиб питання, що дозволяє управляти неминучою складністю предметної області. Чим точніше буде інформація про підобласті та їх типи, тим ефективніше будуть підбиратися технічні рішення для кожної підобласті.

Визначення прихованих піддоменів, які можна було б витягти і зробити явними, грає особливо важливу роль для основних піддоменів. Потрібно завжди прагнути відокремити основні піддомені від усіх інших, щоб можна було прикладати максимум зусиль до найбільш важливих аспектів з точки зору виробленої бізнес-стратегії.

## Обмежені контексти

З розділу 3 відомо, що шаблон обмеженого контексту дозволяє скористатися різними моделями предметної області. Замість побудови моделі «про все і ні про що» (універсальної), можна створити кілька моделей, кожна з яких буде спрямована на вирішення конкретного завдання.

З розвитком і зростанням проєкту обмежені контексти часто втрачають свою спрямованість і накопичують логіку, пов'язану з різними завданнями. Це так звана непередбачена складність. Як і у випадку з піддоменами, дуже важливо періодично переглядати межі обмежених контекстів. Потрібно завжди шукати можливості спрощення моделі, виокремлюючи з неї обмежені контексти, сфокусовані на вирішенні конкретних завдань.

Зростання проєкту може також перевести існуючі приховані проблеми проєктування в явні. Наприклад, можна помітити, що низка обмежених контекстів з часом починає страждати від «балакучості», не здатна завершити яку-небудь операцію без виклику іншого обмеженого контексту. Це може бути явним сигналом про неефективність моделі, яку слід усунути шляхом зміни меж обмежених контекстів, підвищивши їх автономність.

## Агрегати

При розгляді патерну моделі предметної області в розділі 6 для проєктування меж агрегатів використовувався наступний керівний принцип:

### Емпіричне правило:

Агрегати повинні бути якнайменшими та включати лише ті об'єкти, які повинні перебувати в строго узгодженому стані в межах предметної області.

Зі збільшенням системних бізнес-вимог нові функції може бути «зручніше» розподіляти між вже існуючими агрегатами, не переглядаючи принцип підтримки малих розмірів агрегатів. Якщо агрегат розростається і включає дані, не потрібні для суворої узгодженості всієї його бізнес-логіки, це знову буде непередбаченою складністю, від якої слід позбуватися.

Виділення бізнес-функцій з її поміщенням у спеціально виділений агрегат не тільки спрощує початковий агрегат, але й потенційно може спростити обмежений контекст, до якого він належить. Часто така переработка виявляє додаткову раніше приховану модель, яку, ставши явною, слід виділити в інший обмежений контекст.

## Висновок

Як говорив Геракліт, єдиною постійною в житті є зміни. І підприємства тут не є винятком. Щоб зберігати конкурентоспроможність, компанії постійно прагнуть розвиватися і переосмислювати себе. Ці зміни слід розглядати як першочергові елементи процесу проєктування.

З розвитком предметної області зміни в її підобластях повинні бути ідентифіковані і враховані при проєктуванні системи. Переконайтесь, що ваші попередні проєктні рішення відповідають поточному стану предметної області та її підобластей. Дизайн потрібно розвивати за потребою, досягаючи від нього більшого відповідності поточній бізнес-стратегії та потребам бізнесу.

Також важливо усвідомлювати, що на комунікацію і співпрацю між командами, а також на способи інтеграції їх обмежених контекстів можуть впливати зміни в організаційній структурі. Вивчення предметної області - це безперервний процес. З часом, у міру глибшого вивчення предметної області, нові знання потрібно використовувати для розробки стратегічних та тактичних проєктних рішень.

І нарешті, ріст програмного продукту є цілком сприятливим типом змін, але при неправильному управлінні може призвести до катастрофічних наслідків для дизайну та архітектури системи. Отже:

- При розширенні функціональності піддоменів намагайтеся уточнити їх межі, що дозволить прийняти більш зважені проєктні рішення.
- Не дозволяйте обмеженому контексту стати «про все і ні про що» (універсальним). Переконайтесь, що моделі, охоплені обмеженими контекстами, орієнтовані на вирішення конкретних завдань.
- Переконайтесь, що ваші агрегати мають найменші межі. Для виявлення можливостей виділення бізнес-логіки в нові агрегати скористайтеся евристикою строго узгоджених даних.

І останні мудрі думки з цієї теми: постійно перевіряйте різні межі на наявність ознак складності, спричиненої ростом проєкту. Вживайте заходів щодо усунення непередбаченої складності та використовуйте інструменти предметно-орієнтованого проєктування для управління суттєвою складністю предметної області.

## Завдання

1. Які зміни в інтеграції обмежених контекстів часто викликаються ростом організації?

   - А) Перехід партнерства до моделі споживач-постачальник (конформіст, захисний шар або сервіс з відкритим протоколом).
   - Б) Перехід від захисного шару до сервісу з відкритим протоколом.
   - В) Перехід від конформіста до використання загального ядра.
   - Г) Перехід від сервісу з відкритим протоколом до використання загального ядра.

2. Припустимо, що інтеграція обмежених контекстів переходить від конформістських відносин до моделі різних шляхів. Що можна сказати про ці зміни?

   - А) Командам розробників стало складно співпрацювати.
   - Б) Подвоєна функціональність є або допоміжним, або універсальним піддоменом. Подвоєна функціональність є основним піддоменом.
   - В) А і Б.
   - Г) А і В.

3. Які ознаки перетворення допоміжного піддомену в основний?

   - А) Розвивати існуючу модель і впроваджувати нові вимоги стає легше.
   - Б) Розвиток існуючої моделі стає більш проблемним.
   - В) Підобласть все частіше піддається змінам.
   - Г) Б і В.
   - Д) Нічого з вищезазначеного.

4. Які зміни відбуваються в результаті здобуття нової бізнес-компетенції?

   - А) Допоміжний піддомен перетворюється в основний.
   - Б) Допоміжний піддомен перетворюється в універсальний.
   - В) Універсальний піддомен перетворюється в основний.
   - Г) Універсальний піддомен підобласті перетворюється на допоміжний.
   - Д) А і Б.
   - Е) А і В.

5. Яка зміна в бізнес-стратегії може перетворити один з універсальних піддоменів WolfDesk (вигаданої компанії, описаної в передмові) в основний піддомен?
