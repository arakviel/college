# 6. Архітектурні патерни

У попередніх тактичних патернах, розглянутих у цій книзі, описувалися різні способи моделювання та реалізації бізнес-логіки. У цій главі тактичний дизайн розглядатиметься в ширшому контексті, що включає різноманітні способи координації взаємодій і залежностей між компонентами системи.

**Співставлення бізнес-логіки та архітектурних патернів**

Бізнес-логіка — найважливіша, але далеко не єдина частина програмної системи. Для реалізації функціональних і нефункціональних вимог на кодову базу покладається значно ширший спектр завдань. Це включає:
- Взаємодію з користувачами для отримання вхідних даних.
- Надання вихідних даних.
- Використання механізмів зберігання для фіксації стану.
- Інтеграцію із зовнішніми системами та постачальниками інформації.

Різноманіття завдань, які виконує кодова база, сприяє розподілу бізнес-логіки між різними компонентами. Частина логіки може бути реалізована в користувацькому інтерфейсі, базі даних або навіть продубльована у кількох компонентах.

Відсутність чіткої організації у вирішенні цих завдань ускладнює внесення змін до коду. При необхідності змін у бізнес-логіці складно одразу визначити, які частини коду потрібно модифікувати. Деякі зміни можуть мати несподіваний вплив на зовсім, здавалося б, не пов'язані частини системи. Так само легко пропустити ті фрагменти коду, які необхідно змінити. Усі ці проблеми значно збільшують витрати на підтримку кодової бази.

Застосування архітектурних патернів вводить організаційні принципи для різних аспектів кодової бази, встановлюючи чіткі межі між ними. Це дозволяє відповісти на запитання, як саме бізнес-логіка пов’язана з введенням, виведенням та іншими інфраструктурними компонентами системи.

Архітектурні патерни впливають на:
- Взаємодію компонентів між собою.
- Спільний доступ до даних.
- Посилання компонентів один на одного.

Вибір правильного архітектурного патерна має вирішальне значення для забезпечення підтримки реалізації бізнес-логіки в короткостроковій перспективі та спрощення підтримки додатка в майбутньому.

---

**Три основні архітектурні патерни**

Давайте розглянемо три ключові архітектурні патерни додатків:
1. **Шарова архітектура** (Layered Architecture).
2. **Порти й адаптери** (Ports and Adapters).
3. **CQRS** (Command Query Responsibility Segregation).

---

**Шарова архітектура** Одним із найпоширеніших архітектурних патернів є **шарова архітектура** (Layered Architecture). У цьому підході кодова база структурується в горизонтальні шари, кожен з яких вирішує одну з таких технічних задач:
- Взаємодія з користувачами.
- Реалізація бізнес-логіки.
- Збереження даних.


  **Структура шарів представлена на рисунку:**
- **Шар представлення (Presentation Layer).**
- **Шар бізнес-логіки (Business Logic Layer).**
- **Шар доступу до даних (Data Access Layer).**

![](/images/30.png)

---

**Шар представлення (Presentation Layer)**
На шарі представлення реалізується користувацький інтерфейс програми для взаємодії з її користувачами. У традиційній формі цей шар включає графічний інтерфейс, наприклад, веб-інтерфейс або настільний застосунок.

У сучасних системах шар представлення охоплює ширший спектр засобів взаємодії:
- **Графічний інтерфейс користувача (GUI).**
- **Інтерфейс командного рядка (CLI).**
- **API для інтеграції з іншими системами.**
- **Підписка на події у брокері повідомлень.**
- **Теми повідомлень для публікації подій.**

Шар представлення забезпечує отримання системою запитів із зовнішнього середовища та передачу результатів. По суті, це публічний інтерфейс програми.

![](/images/31.png)
---

**Шар бізнес-логіки (Business logic layer)**

Як видно з назви, цей шар відповідає за реалізацію та інкапсуляцію бізнес-логіки програми. Саме тут реалізуються бізнес-рішення. Як зазначає Ерік Еванс (Eric Evans), цей шар є серцем програмного забезпечення.

На цьому шарі реалізуються патерни бізнес-логіки, описані в розділах 5-7, наприклад, активні записи або модель предметної області (див. рис.).

![](/images/32.png)

---

**Шар доступу до даних (Data access layer)**

Шар доступу до даних забезпечує доступ до механізмів зберігання інформації.

У первісній формі патерна передбачалася лише база даних системи. Але, як і у випадку з шаром представлення, відповідальність цього шару у сучасних системах стала значно ширшою:

1. **Багато баз даних.** З часів революції NoSQL система зазвичай працює з кількома базами даних. Наприклад, документоорієнтоване сховище може виступати в ролі робочої бази даних, пошуковий індекс — для динамічних запитів, а база даних в оперативній пам'яті — для високопродуктивних операцій.

2. **Інші засоби зберігання.** Традиційні бази даних не є єдиним засобом зберігання інформації. Наприклад, для зберігання файлів може використовуватися хмарне об'єктне сховище, а для зв'язку між функціями програми — шина повідомлень.

3. **Зовнішні постачальники інформації.** Цей шар також включає інтеграцію з API зовнішніх систем або сервісами хмарних провайдерів, такими як переклад, дані фондового ринку, розпізнавання аудіо тощо (див. рис)

![](/images/33.png)

---

**Зв'язок між шарами**
Шари інтегровані у модель комунікації "зверху вниз": як показано на рис. 8.5, кожен шар може мати залежність лише від шару, який знаходиться безпосередньо під ним. Це забезпечує розділення задач реалізації та зменшення обміну знаннями між шарами.

На рис. 8.5 шар представлення звертається лише до шару бізнес-логіки. Він не знає нічого про дизайн шару доступу до даних.

![](/images/34.png)

---

**Варіація: Сервісний шар (Service layer)**
Зазвичай патерн шарової архітектури розширюється додатковим сервісним шаром.
**Сервісний шар (Service layer)**
Визначає межу застосунку через набір сервісів, які встановлюють доступні дії та координують реакцію програми на кожну дію.
— _"Патерни архітектури корпоративних додатків"_
Сервісний шар виступає посередником між існуючими шарами програми: представлення та бізнес-логіки.

Розглянемо наступний код:

```csharp
namespace MvcApplication.Controllers
public class UserController: Controller
{
    [AcceptVerbs(HttpVerbs.Post)]
    public ActionResult Create(ContactDetails contactDetails)
    {
        OperationResult result = null;
        try
        {
            _db.StartTransaction();
            var user = new User();
            user.SetContactDetails(contactDetails);
            user.Save();
            _db.Commit();
            result = OperationResult.Success;
        }
        catch (Exception ex)
        {
            _db.Rollback();
            result = OperationResult.Exception(ex);
        }
        return View(result);
    }
}
```

Показаний у прикладі MVC-контролер належить до шару представлення. Він надає інтерфейс для створення нового користувача. Створення нового екземпляра та його збереження здійснюється через об'єкт активного запису `user`.
Більше того, цей код керує транзакціями бази даних, щоб у разі помилки повернути правильну відповідь. Як показано на рис., для подальшого відокремлення шару представлення та базової бізнес-логіки, логіку керування транзакціями можна перенести на сервісний шар.

![](/images/35.png)

# Сервісний шар як логічна межа

Важливо зазначити, що в контексті архітектурного патерна сервісний шар є логічною межею. Його не слід розглядати як фізичний сервіс.

Сервісний шар виступає фасадом шару бізнес-логіки: він надає інтерфейс, який відповідає методам публічного інтерфейсу, інкапсулюючи виклики нижчих шарів.

Наприклад:

```csharp
interface CampaignManagementService {
    OperationResult CreateCampaign(CampaignDetails details);
    OperationResult Publish(CampaignId id, PublishingSchedule schedule);
    OperationResult Deactivate(CampaignId id);
    OperationResult AddDisplayLocation(CampaignId id, DisplayLocation newLocation);
}
```

Усі показані вище методи відповідають публічному інтерфейсу системи. Проте їм не вистачає деталей реалізації, пов'язаних із представленням. Відповідальність шару представлення обмежується наданням необхідних вхідних даних сервісному шару та поверненням його відповідей викликаючій стороні.

---

## Рефакторинг з винесенням логіки оркестрації у сервісний шар

```csharp
namespace ServiceLayer {
    public class UserService {
        public OperationResult Create(ContactDetails contactDetails) {
            OperationResult result = null;
            try {
                _db.StartTransaction();
                var user = new User();
                user.SetContactDetails(contactDetails);
                user.Save();
                _db.Commit();
                result = OperationResult.Success;
            } catch (Exception ex) {
                _db.Rollback();
                result = OperationResult.Exception(ex);
            }
            return result;
        }
    }
}

namespace MvcApplication.Controllers {
    public class UserController : Controller {
        [AcceptVerbs(HttpVerbs.Post)]
        public ActionResult Create(ContactDetails contactDetails) {
            var result = userService.Create(contactDetails);
            return View(result);
        }
    }
}
```

---

## Переваги явного сервісного шару

1. **Багаторазове використання** : Один і той самий сервісний шар може бути використаний кількома публічними інтерфейсами, наприклад, графічним інтерфейсом користувача та API. Це усуває необхідність дублювати логіку оркестрації.

2. **Модульність коду** : Усі пов'язані методи зосереджені в одному місці.

3. **Розділення логіки** : Чітке розділення шару представлення та бізнес-логіки.

4. **Спрощення тестування** : Функціональність бізнес-логіки стає легше тестувати.

---

## Коли сервісний шар не потрібен?

- Якщо бізнес-логіка реалізована у вигляді транзакційного сценарію, то вона сама є сервісним шаром, оскільки вже надає методи для формування публічного інтерфейсу системи. У цьому випадку API сервісного шару просто дублює інтерфейси транзакційних сценаріїв.

## Коли сервісний шар необхідний?

- Якщо патерн бізнес-логіки потребує зовнішнього оркестратора, як у випадку з патерном активного запису. У такому випадку на сервісному шарі реалізується патерн транзакційного сценарію, а активні записи, з якими він працює, знаходяться на шарі бізнес-логіки.

**Термінологія**
В інших джерелах інформації можуть зустрічатися й інші терміни, які використовуються для опису шарової архітектури:

- **Шар представлення** = шар користувацького інтерфейсу.

- **Сервісний шар** = прикладний шар.

- **Шар бізнес-логіки** = шар предметної області = шар моделі.

- **Шар доступу до даних** = шар інфраструктури.

Щоб уникнути плутанини, патерн тут представлено з використанням початкової термінології. Водночас я схиляюся до таких понять, як «шар користувацького інтерфейсу» та «шар інфраструктури», оскільки ці терміни краще відображають обов’язки сучасних систем та шарів додатків, не допускаючи плутанини з фізичними межами сервісів.

---

**Коли краще використовувати шарову архітектуру**
Завдяки наявності у цьому архітектурному патерні залежності між шарами бізнес-логіки та доступу до даних, він добре підходить для систем, бізнес-логіка яких реалізована з використанням транзакційного сценарію або патерна активного запису.
Проте патерн ускладнює реалізацію моделі предметної області, де бізнес-сутності (агрегати й об'єкти-значення) не повинні мати жодної залежності від базової інфраструктури чи знань про неї. У шаровій архітектурі з її залежністю зверху вниз для виконання цієї вимоги доведеться обходити шари. Реалізувати модель предметної області в шаровій архітектурі все ж можна, але патерн, який розглядається далі, підходить для цього набагато краще.

---

**Додатково: порівняння шарів і рівнів**
Шарову архітектуру часто плутають із архітектурою N-Tier (багаторівневою) та навпаки. Незважаючи на схожість між двома патернами, шари й рівні (tiers) концептуально відрізняються:

- **Шар** — це логічна межа.

- **Рівень** — це фізична межа.

Усі шари в шаровій архітектурі мають один і той самий життєвий цикл: вони реалізуються, розвиваються й розгортаються як єдине ціле. А рівень — це незалежно розгортований сервіс, сервер або система.

![](/images/36.png)

Розглянемо, наприклад, систему з архітектурою N-Tier:

- Браузер, який працює на настільному комп’ютері або мобільному пристрої.

- Зворотний проксі-сервер, який перенаправляє запити до веб-додатку.

- Веб-додаток, який працює на веб-сервері й взаємодіє із сервером бази даних.

Усі ці компоненти можуть працювати на одному фізичному сервері або бути розподілені між кількома серверами. Однак, оскільки кожен компонент може розгортатися й управлятися незалежно від інших, це рівні, а не шари.

Шари всередині веб-додатку є логічними межами.

---

**Порти й адаптери (Ports and Adapters)**
Архітектура портів і адаптерів усуває недоліки шарової архітектури й краще підходить для реалізації складнішої бізнес-логіки.
Цікаво, що обидва патерни дуже схожі. Рефакторимо шарову архітектуру в архітектуру портів і адаптерів.
**Термінологія**
По суті, і шар представлення, і шар доступу до даних є інтеграцією із зовнішніми компонентами: базами даних, зовнішніми сервісами й фреймворками користувацького інтерфейсу. Ці технічні подробиці не відображають бізнес-логіку системи, тому всі подібні інфраструктурні задачі об’єднуються в один «шар інфраструктури».

![](/images/37.png)

---

**Принцип інверсії залежностей (Dependency Inversion Principle)**
Принцип інверсії залежностей (Dependency Inversion Principle — DIP) говорить, що високорівневі модулі, які реалізують бізнес-логіку, не повинні залежати від низькорівневих модулів. Але в традиційній шаровій архітектурі відбувається саме це. Шар бізнес-логіки залежить від шару інфраструктури. Щоб відповідати принципу DIP, давайте, як показано на рис, розвернемо залежності у зворотному напрямку.

![](/images/38.png)

**Шар бізнес-логіки**
Тепер шар бізнес-логіки розташований не між технологічними шарами, а займає центральну позицію. Він не залежить ні від одного з інфраструктурних компонентів системи.
Нарешті, для публічного інтерфейсу системи ми додаємо прикладний шар. Як і сервісний шар у шаровій архітектурі, він описує всі операції, що надаються системою, і керує бізнес-логікою для їх виконання. Отримана в результаті архітектура зображена на рис.

![](/images/39.png)

Архітектура, зображена на рис, представляє архітектурний патерн портів і адаптерів (Ports and Adapters). Шар бізнес-логіки не залежить ні від одного з нижніх шарів, що дозволяє реалізувати патерни моделі предметної області та моделі предметної області, заснованої на подіях (Event Sourced Domain Model).

---

**Чому цей патерн називається порти й адаптери?**
Щоб відповісти на це питання, розглянемо, як інфраструктурні компоненти інтегровані з бізнес-логікою.**Інтеграція інфраструктурних компонентів**
Основна мета архітектури портів і адаптерів — відокремити бізнес-логіку системи від її інфраструктурних компонентів.
Замість того, щоб посилатися на інфраструктурні компоненти або викликати їх напряму, шар бізнес-логіки визначає «порти», які мають бути реалізовані на шарі інфраструктури. А на шарі інфраструктури реалізуються «адаптери» — конкретні реалізації інтерфейсів портів для роботи з різними технологіями (див. рис).

![](/images/40.png)

**Абстрактні порти** стають конкретними адаптерами на шарі інфраструктури або шляхом впровадження залежностей, або шляхом налаштування під час початкового завантаження.
Наприклад, ось як виглядає можливе визначення порту та конкретний адаптер для шини повідомлень:

```csharp
namespace App.BusinessLogicLayer
{
puЬlic interface IMessaging
{
void PuЬlish(Message payload);
}
}
void SuЬscribe(Message type, Action callback);

namespace App.Infrastructure.Adapters
{
puЬlic class SQSBus: IMessaging { ...
}
}
```

**Варіанти**

Архітектура портів і адаптерів також відома як гексагональна архітектура, цибулинна архітектура та чиста архітектура. Усі ці патерни ґрунтуються на одних і тих самих принципах проєктування, мають однакові компоненти й характеризуються однаковими відносинами між ними, але, як і у випадку зі шаровою архітектурою, термінологія може відрізнятися:

♦ Прикладний шар = сервісний шар = шар користувацького сценарію.

♦ Шар бізнес-логіки = шар предметної області = шар ядра.

І все ж ці патерни можна помилково вважати концептуально різними. Це ще один приклад важливості єдиної мови.

**Коли доцільніше використовувати порти й адаптери**

Відокремлення бізнес-логіки від усіх технологічних питань робить архітектуру портів і адаптерів ідеальною для бізнес-логіки,реалізованої за допомогою патерну моделі предметної області.

### Розділення відповідальності команд і запитів

(Command-Query Responsibility Segregation)

Патерн розділення відповідальності команд і запитів (command-query responsibility segregation – CQRS) базується на тих самих принципах організації бізнес-логіки та інфраструктури, що й патерн портів та адаптерів. Але він відрізняється способом управління даними системи. Цей патерн дозволяє представляти дані системи в декількох персистентних моделях.

Давайте розглянемо, навіщо може знадобитися таке рішення і як його реалізувати.

### Мультипарадигмальне моделювання

(Polyglot modelling)

Використання єдиної моделі для всіх потреб системи може бути ускладненим або навіть неможливим. Наприклад, як уже згадувалося у главі 7, обробка транзакцій (online transaction processing – OLTP) та аналітична обробка (online analytical processing – OLAP) можуть вимагати різних представлень даних.

Ще одна причина для роботи з кількома моделями може бути пов’язана з поняттям мультипарадигмального збереження даних (polyglot persistence). Ідеальної бази даних не існує. Або, як каже Грег Янг (Greg Young), у всіх баз даних є недоліки, і у кожної свої: часто доводиться балансувати між потребами у масштабуванні, узгодженістю даних або підтримуваних типів запитів.

Альтернативою пошуку ідеальної бази даних є мультипарадигмальна модель збереження даних: використання кількох баз даних для реалізації різних вимог, пов’язаних із даними. Наприклад, одна система може використовувати як робочу базу даних документно-орієнтовану, для аналітики або звітності – колоночну, а для реалізації надійного пошуку – пошуковий движок.

І, нарешті, що потрібно згадати – патерн CQRS тісно пов’язаний із джерелом подій (event sourcing). Спочатку CQRS був визначений для подолання обмежень у виконанні запитів при використанні моделі, заснованої на подіях (event sourced domain model): за один раз можна було запитувати події лише одного екземпляра агрегату. Патерн CQRS надає можливість матеріалізації моделей, спроєктованих у фізичні бази даних, що підходять для гнучких запитів.

З урахуванням сказаного у цій главі CQRS «відокремлюється» від джерела подій (event sourcing). Я хочу показати, що CQRS застосовний навіть у тому випадку, якщо бізнес-логіка реалізована із використанням будь-якого іншого патерну.

Давайте розглянемо, як CQRS дозволяє використовувати одразу кілька механізмів збереження для представлення різних моделей даних розроблюваної системи.

### Реалізація

Як випливає із назви, патерн розділяє обов’язки моделей системи. Існують два типи моделей: модель виконання команд і моделі читання.

### Модель виконання команд

CQRS виділяє єдину модель для виконання операцій, які змінюють стан системи (системні команди). Ця модель використовується для реалізації бізнес-логіки, перевірки дотримання правил і забезпечення інваріантів.

Модель виконання команд також є єдиною моделлю, що представляє строго узгоджені дані – джерелом істини (source of truth).

Повинна бути надана можливість зчитування строго узгодженого стану бізнес-об’єкта і підтримка оптимістичного управління конкурентним доступом для оновлення цих об’єктів.

### Моделі читання (проєкції)

Система може визначити стільки моделей, скільки потрібно для надання даних користувачам або інформації іншим системам.

Модель читання – це попередньо кешована проєкція. Вона може знаходитися у базі даних, у звичайному файлі або у кеші в пам’яті. Правильна реалізація CQRS дозволяє стерти всі дані проєкції і відновити її з нуля. Вона також дозволяє розширити систему додатковими проєкціями у майбутньому – моделями, які неможливо було передбачити спочатку.

І, нарешті, моделі читання доступні тільки для читання. Жодна із системних операцій не може безпосередньо змінювати дані моделей читання.

### Проєктування моделей читання

Щоб моделі читання запрацювали, система повинна проєктувати зміни із моделі виконання команд.

![](/images/41.png)

Проекція моделей читання аналогічна поняттю матеріалізованого представлення
(materialized view) у реляційних базах даних: при кожному оновленні вихідної
таблиці зміни мають відображатися в попередньо кешованих представленнях.

А тепер давайте розглянемо два способи створення проєкцій: синхронний та асинхронний.

### Синхронні проєкції

При синхронному оновленні проєкцій оновлення даних відбувається за моделлю
наздоганяючої підписки (catch-up subscription):

♦ Механізм проєктування запитує в OLTP-базі нові або оновлені
записи після останньої контрольної точки (checkpoint).

♦ Механізм проєктування використовує оновлені дані для створення або
оновлення моделей читання.

♦ Механізм проєктування зберігає контрольну точку останнього обробленого
запису.
Це значення буде використовуватися під час наступної ітерації
для додавання або зміни записів після останнього обробленого запису.Цей процес показаний на рис. у вигляді діаграми послідовності.

![](/images/42.png)

Щоб наздоганяюча підписка працювала, модель виконання команд повинна встановлювати
контрольну точку (checkpoint) для всіх нових або оновлених записів бази даних. Механізм
зберігання також має підтримувати запит записів на основі контрольних точок.

Контрольна точка може бути реалізована за допомогою можливостей баз
даних. Наприклад, як показано на таблиці. , для генерації унікальних
інкрементальних чисел під час вставки або оновлення рядка у SQL Server може
використовуватися стовпець «rowversion». У базах даних, де такої можливості
немає, можна реалізувати спеціальне рішення, яке збільшує поточний лічильник і
додає його до кожного зміненого запису.Важливо переконатися, що запит на основі контрольної точки повертає узгоджені
результати. Якщо останній повернений запис має значення контрольної точки 10,
під час наступного виконання жоден новий запит не повинен мати значення менше
за 10. Інакше ці записи будуть пропущені механізмом проєктування, що призведе до
несумісності моделей.

| Id  | Ім'я    | Прізвище | Checkpoint         |
| --- | ------- | -------- | ------------------ |
| 1   | Том     | Кук      | 0x0000000000001792 |
| 2   | Гарольд | Еліот    | 0x0000000000001793 |
| 3   | Діана   | Деніелс  | 0x0000000000001796 |
| 4   | Діана   | Деніелс  | 0x0000000000001795 |

Автоматично згенерований стовпець контрольної точки (checkpoint)
у реляційній базі даних

**Метод синхронного проєктування** спрощує додавання нових проєкцій і
регенерацію існуючих із самого початку. У останньому випадку достатньо лише
скинути контрольну точку на 0; механізм проєктування просканує записи і
відновить проєкції з нуля.

### Асинхронні проєкції

У сценарії асинхронного проєктування модель виконання команд публікує всі
зафіксовані зміни в шину повідомлень. Як показано на рис, механізми
проєктування системи можуть підписуватися на опубліковані повідомлення і
використовувати їх для оновлення моделей читання.

![](/images/43.png)

### Складнощі

Незважаючи на очевидні переваги методу асинхронного проєктування в питаннях масштабування і продуктивності, він є більш уразливим до помилок, що виникають під час конкурентного доступу. Якщо повідомлення обробляються не за порядком або дублюються, у моделі читання можуть проєктуватися несумісні дані.

Цей метод також ускладнює додавання нових проєкцій або регенерацію існуючих.

Тому завжди рекомендується реалізовувати синхронну проєкцію, а в разі необхідності надбудовувати над нею додаткову асинхронну проєкцію.

---

### Розподіл моделей

В архітектурі CQRS відповідальності моделей розділені відповідно до їх типу. Команда може працювати лише в строго узгодженій моделі виконання команд. Запит не може безпосередньо змінювати збережений стан системи – ні моделі читання, ні моделі виконання команд.

Існує поширене хибне уявлення, що команда може лише змінювати дані, а дані можна витягувати для відображення лише через модель читання. Іншими словами, команда, яка викликає виконання методів, ніколи не повинна повертати жодних даних. Це не так. Такий підхід створює зайві труднощі і псує враження користувачів про систему.

Команда завжди повинна повідомляти стороні, що викликає, про успішний або невдалий результат її виконання. Якщо виконання не вдалося, то з якої причини? Чи не пройшли вхідні дані валідацію, чи виникла технічна проблема? Компонент програми, що викликає команду, має знати, як внести виправлення.

Отже, команда може і в багатьох випадках повинна повертати дані, наприклад, якщо інтерфейс користувача повинен відображати зміни, отримані в результаті виконання команди. Це спрощує роботу користувачів із системою, оскільки вони одразу отримують зворотний зв'язок на свої дії. Також це надає можливість використовувати повернені значення у подальших робочих процесах користувачів, усуваючи необхідність у зайвих обмінах даними.

Єдине обмеження полягає в тому, що повернені дані мають виходити з строго узгодженої моделі, а саме з моделі виконання команд, оскільки ми не можемо чекати, доки проєкція набуде узгодженого стану.

---

### Коли краще використовувати CQRS

Застосування патерна CQRS може бути доречним для програм, яким потрібно працювати з одними і тими ж даними одразу в кількох моделях, потенційно збережених у базах даних різних типів.

З точки зору практичного застосування, патерн підтримує основну цінність предметно-орієнтованого проєктування, що полягає у роботі з найефективнішими моделями для вирішення завдань і постійному вдосконаленні моделі предметної області.

З точки зору інфраструктури, CQRS дозволяє використовувати можливості різних типів баз даних: наприклад, для збереження моделі виконання команд використовувати реляційні бази даних, для повнотекстового пошуку – індекс пошуку, а для швидкого витягування даних – заздалегідь оброблені файли.
Крім того, CQRS природно підходить для моделей предметної області, заснованих на подіях (_event sourced domain model_). Модель «Події як джерело даних» (_Event Sourcing_) унеможливлює вибірку записів на основі станів агрегатів, але CQRS відкриває таку можливість, проєктуючи стани в бази даних.

---

### Сфера застосування

Розглянуті тут патерни – багаторівнева архітектура, архітектура портів і адаптерів та CQRS – не повинні слугувати загальними організаційними принципами для всієї системи. Їх не слід вважати обов'язковими високорівневими архітектурними патернами для всього обмеженого контексту.
Наприклад, в обмеженому контексті, який охоплює кілька піддоменів, піддомени можуть бути різних типів: основні (_core_), допоміжні (_supporting_) чи універсальні (_generic_). Навіть для піддоменів одного типу можуть знадобитися різні бізнес-логіки та архітектурні патерни.
Єдина архітектура в межах всього контексту може призвести до зайвої складності.

![](/images/44.png)

Наша мета полягає в ухваленні проєктних рішень відповідно до реальних потреб і бізнес-стратегії. На додаток до рівнів, що розділяють
систему по горизонталі, можна ще ввести додаткове вертикальне розбиття. Вкрай важливо визначити логічні межі для модулів, що інкапсулюють систему.
Тактичний задумщо інкапсулюють окремі піддомени бізнесу, і для кожного з них скористатися відповідними інструментами (рис).

Відповідні вертикальні межі роблять монолітний обмежений контекст модульним і не дають йому перетворитися на так звану велику грудку бруду.

![](/images/45.png)

### Висновок

**Багатошарова архітектура** передбачає поділ кодової бази на основі технологічних завдань, що вирішуються. Оскільки цей патерн об'єднує бізнес-логіку з реалізацією доступу до даних, він добре підходить для систем, які використовують активні записи.В **архітектурі портів і адаптерів** відносини інвертуються: бізнес-логіка стає центральною і відділяється від усіх інфраструктурних залежностей. Цей патерн добре підходить для бізнес-логіки, реалізованої за допомогою патерна моделі предметної області.**Патерн CQRS** представляє одні й ті самі дані одразу в декількох моделях. Незважаючи на те, що цей патерн є обов’язковим для систем, побудованих на моделі предметної області, заснованої на подіях (_event-source domain model_), він також може використовуватися в будь-яких системах, які потребують роботи з декількома моделями збереження інформації.
Патерни, які будуть розглянуті у наступному розділі, призначені для вирішення архітектурних завдань із акцентом на реалізацію надійної взаємодії між різними компонентами системи.

### Вправи

**Розділ 8. Архітектурні патерни (стор. 163)**

1. Які з розглянутих архітектурних патернів можна використовувати з бізнес-логікою, реалізованою у вигляді патерна активного запису?

- А) Багатошарова архітектура.
- Б) Порти і адаптери.
- В) CQRS.
- Г) А і Б.

2. Який із розглянутих архітектурних патернів відокремлює бізнес-логіку від інфраструктурних задач?

- А) Багатошарова архітектура.
- Б) Порти і адаптери.
- В) CQRS.
- Г) Б і В.

3. Припустимо, що при реалізації патерна портів і адаптерів необхідно інтегрувати шину повідомлень хмарного провайдера. На якому шарі повинна бути реалізована інтеграція?

- А) На шарі бізнес-логіки.
- Б) На прикладному шарі.
- В) На шарі інфраструктури.
- Г) На будь-якому шарі.

4. Яке з наведених тверджень стосовно патерна CQRS є правильним?

- А) Асинхронні проекції легше масштабувати.
- Б) Можна використовувати або синхронну, або асинхронну проекцію, але не обидві одночасно.
- В) Команда не повертає ніякої інформації стороні, що викликає. Для отримання результатів виконаних дій код, що викликає, завжди повинен використовувати моделі читання.
- Г) Команда може повертати інформацію, якщо вона виходить зі строго узгодженої моделі.
- Д) А і Г.

5. Патерн CQRS дозволяє представляти одні й ті самі бізнес-об’єкти у декількох моделях збереження інформації, дозволяючи таким чином в одному й тому ж обмеженому контексті працювати з декількома моделями. Чи суперечить це уявленню про те, що обмежений контекст є межею моделі?
